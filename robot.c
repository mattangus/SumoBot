#pragma config(Sensor, S1,     LightSensor,    sensorLightActive)
#pragma config(Sensor, S2,     LeftBumpSensor, sensorTouch)
#pragma config(Sensor, S3,     RightBumpSensor, sensorTouch)
#pragma config(Sensor, S4,     DistanceSensor, sensorSONAR)
#pragma config(Motor,  motorA,          Middle,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          Right,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          Left,          tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "robot.h"


task main()
{
	setup();
	wait1Msec(5000); //wait 5 seconds

	mainloop();
	//float radius = startState();
	//mainloop(ratio);
	//
	//trunState();
	//runState();
}

void mainloop()
{
	initialState();
	bool finished = false;
	bool cancel = false;
	while(!finished) {
		int dist = turnState(dirLeft,&cancel);
		if(cancel)
		{
			cancel = false;
			continue;
		}

		counterTurnState(dist, dirRight,&cancel);
		if(cancel)
		{
			cancel = false;
			continue;
		}
		attackState(&cancel);

		if(cancel)
		{
			cancel = false;
			continue;
		}
		//displayInfo();
		//finished = true;
	}
}

float startState()
{
	bool finished = false;
	float radius = SensorValue[DistanceSensor]/2.0;

	while(!finished)
	{
		displayInfo();
	}
	return radius;
}

int turnState(direction dir, bool* cancel)
{
	int dist = SensorValue[DistanceSensor];

	while(dist > distanceThreshold )
	{
		if(checkEdge()||checkBack())
		{
			(*cancel) = true;
			return 0;
		}
		rotate(halfRoboWidthCm*2,turnSpeed ,dir);
		dist = SensorValue[DistanceSensor];
		//nxtDisplayCenteredTextLine(0,"dist %d",dist);
		//nxtDisplayCenteredTextLine(0,"turnstate");
		//displayInfo();
	}
	//move(50,50);
	return dist;
}

void counterTurnState(int distance, direction dir, bool* cancel)
{
	//rotate(distance,10,dir);
	int dist = SensorValue[DistanceSensor];
	int endTime = time10[T1]+100;
	while(dist > distanceThreshold && endTime > time10[T1])
	{
		if(checkEdge()||checkBack())
		{
			(*cancel) = true;
			return;
		}
		rotate(distance,turnSpeed,dir);
		dist = SensorValue[DistanceSensor];
		//nxtDisplayCenteredTextLine(0,"counterturnstate");
	//	nxtDisplayCenteredTextLine(0,"dist %d",dist);
		//displayInfo();
	}
}

void attackState(bool* cancel)
{
	int offCounter = 0;
	int pos = 0;
	while(offCounter < 1000)  {
		if(SensorValue[DistanceSensor] >= distanceThreshold && SensorValue[DistanceSensor] <= 255)
			offCounter++;
		else
			offCounter=0;
		//nxtDisplayCenteredTextLine(0,"dist %d",SensorValue[DistanceSensor]);
		//nxtDisplayCenteredTextLine(1,"offCount %d",offCounter);
		if(checkEdge()||checkBack())
		{
			(*cancel) = true;
			return;
		}
		move(attackSpeed,attackSpeed);
	}
}
bool checkBack() {
	if (SensorValue[LeftBumpSensor] == 1)
	{
		rotate(halfRoboWidthCm*2,turnSpeed,dirRight);
		wait1Msec(1000);
		return true;
	}
	else if (SensorValue[RightBumpSensor] == 1){
		rotate(halfRoboWidthCm*2,turnSpeed,dirLeft);
		wait1Msec(1000);
		return true;
	}
	else
		return false;
}
bool checkEdge() {
	//displaySensorValues(1, LightSensor);
	if (getCurrentColour() == white) {
		move(-backSpeed,-backSpeed);
		wait1Msec(1000);
		return true;
	}
	return false;
}
void runState()
{
}

void move(int leftVal, int rightVal)
{
	motor[Left] = leftVal*-1;
	motor[Right] = rightVal*-1;
}

void rotateAndTrack(float radius, int speed, int direction)
{

}

void rotate(float radius, int speed, direction dir)
{
	//virtual because they don't actually correspond to left/right
	int virtualRightV;
	int virtualLeftV;

	float tempRatio;
	if(radius-halfRoboWidthCm==0)
	{
		tempRatio = 0;
		virtualRightV = speed;
		virtualLeftV = 0;
	}
	else
	{
		tempRatio = (radius+halfRoboWidthCm)/(radius-halfRoboWidthCm);
		virtualRightV = speed/tempRatio;
		virtualLeftV = speed;
	}
	//rotate right (clockwise)
	if(dir == dirRight)
	{
		move(virtualRightV,virtualLeftV);
	}//counter clockwise
	else
	{
		move(virtualLeftV,virtualRightV);
	}
}

void resetMotor(int motorNum)
{
	nMotorEncoder[motorNum] = 0;
}

float getMotorDistance(int motorNum)
{
	float curVal = nMotorEncoder[motorNum];
	return (curVal * wheelCerc)/360.0;
}

colour getCurrentColour()
{
	if(SensorValue[LightSensor] > whiteThreshold)
		return white;
	return black;
}

void setup()
{

}

void displayInfo()
{
	nxtDisplayCenteredTextLine(lineNum++,"LMot %d",motor[Left]);
	nxtDisplayCenteredTextLine(lineNum++,"RMot %d",motor[Left]);
//	displaySensorValues(lineNum++, LightSensor);
	//displaySensorValues(lineNum++, DistanceSensor);
	nxtDisplayCenteredTextLine(lineNum++,"LEn %d",nMotorEncoder[Left]);
	nxtDisplayCenteredTextLine(lineNum++,"REn %d",nMotorEncoder[Right]);
	lineNum = 0;
}

void displayInfo(float custom)
{
	displayInfo();
	//nxtDisplayCenteredTextLine(lineNum++,"custom %f",custom);
}


bool RightHit = false;
bool DistanceOut = false;

void initialState() {
	//rotateRight(45);
	nMotorEncoder[Left] = 0;
	nMotorEncoder[Right] = 0;
	int distanceOut = 50;
	bool running = true;
	while(true){
		//moveBackwards();
		move(100,100);
		if (checkEdge() || checkBack())
			return;

		if (SensorValue[RightBumpSensor] == 1)  {
			RightHit = true;
			break;
		}
		int dist = nMotorEncoder[Left]
		if (abs(dist) > distanceOut) {
			DistanceOut = true;
			break;
		}
	}
}


void moveBackwards() {
	int speed = 60;
	motor[Left] = speed;
	motor[Right] = speed;

}
void rotateRight(int degrees) {
	int enc = degrees;
	nMotorEncoder[Right]= 0;
	while(abs(nMotorEncoder[Right])<enc) {
		move(-60,60);
		//nxtDisplayCenteredTextLine(4,"REn %d",nMotorEncoder[Right]);


	}
	move(0,0);
}

void rotateLeft(int degrees) {
	int enc = degrees;
	nMotorEncoder[Left] = 0;
	while(abs(nMotorEncoder[Left])<enc) {
		move(50,-50);
	}
	move(0,0);
}
