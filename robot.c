#pragma config(Sensor, S1,     LightSensor,    sensorLightActive)
#pragma config(Sensor, S2,     LeftBumpSensor, sensorTouch)
#pragma config(Sensor, S3,     RightBumpSensor, sensorTouch)
#pragma config(Sensor, S4,     DistanceSensor, sensorSONAR)
#pragma config(Motor,  motorA,          Middle,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          Right,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          Left,          tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "robot.h"


task main()
{
	setup();
	//wait1Msec(5000); //wait 5 seconds
	mainloop();
	//float radius = startState();
	//mainloop(ratio);
	//
	//trunState();
	//runState();
}

void mainloop()
{
//	initialState();
	bool finished = false;
	while(!finished) {
		int dist = turnState(dirLeft);
		counterTurnState(dist, dirRight);
		attackState();
		//displayInfo();
		finished = true;
	}
}

float startState()
{
	bool finished = false;
	float radius = SensorValue[DistanceSensor]/2.0;

	while(!finished)
	{
		displayInfo();
	}
	return radius;
}

int turnState(direction dir)
{
	int dist = SensorValue[DistanceSensor];

	while(dist > distanceThreshold )
	{
		checkEdge();
		checkBack();
		rotate(halfRoboWidthCm*2,20,dir);
		dist = SensorValue[DistanceSensor];
		nxtDisplayCenteredTextLine(0,"dist %d",dist);
		//nxtDisplayCenteredTextLine(0,"turnstate");
		//displayInfo();
	}
	//move(50,50);
	return dist;
}

void counterTurnState(int distance, direction dir)
{
	//rotate(distance,10,dir);
	int dist = SensorValue[DistanceSensor];
	int endTime = time10[T1]+100;
	while(dist > distanceThreshold && endTime > time10[T1])
	{
		checkEdge();
		checkBack();
		rotate(distance,20,dir);
		dist = SensorValue[DistanceSensor];
		//nxtDisplayCenteredTextLine(0,"counterturnstate");
		nxtDisplayCenteredTextLine(0,"dist %d",dist);
		//displayInfo();
	}
}

void attackState()
{
	int offCounter = 0;
	int pos = 0;
	while(offCounter < 1000)  {
		if(SensorValue[DistanceSensor] >= distanceThreshold && SensorValue[DistanceSensor] <= 255)
			offCounter++;
		else
			offCounter=0;
		nxtDisplayCenteredTextLine(0,"dist %d",SensorValue[DistanceSensor]);
		nxtDisplayCenteredTextLine(1,"offCount %d",offCounter);
		//checkEdge();
		//checkBack();
		move(40,40);
	}
}
void checkBack() {
	if (SensorValue[LeftBumpSensor] == 1)
	{
		rotate(halfRoboWidthCm*2,10,1);
		sleep(1000);
	}
	else if (SensorValue[RightBumpSensor] == 1){
		rotate(halfRoboWidthCm*2,10,-1);
		sleep(1000);
	}
	else
		return;
}
void checkEdge() {
	displaySensorValues(1, LightSensor);
	if (SensorValue[LightSensor] > whiteThreshold) {
		move(-20,-20);
		sleep(1000);
	}
	//+displaySensorValues(1, LightSensor);
}
void runState()
{
}

void move(int leftVal, int rightVal)
{
	setMotor(Left,leftVal*-1);
	setMotor(Right,rightVal*-1);
}

void rotateAndTrack(float radius, int speed, int direction)
{

}

void rotate(float radius, int speed, direction dir)
{
	//virtual because they don't actually correspond to left/right
	int virtualRightV;
	int virtualLeftV;

	float tempRatio;
	if(radius-halfRoboWidthCm==0)
	{
		tempRatio = 0;
		virtualRightV = speed;
		virtualLeftV = 0;
	}
	else
	{
		tempRatio = (radius+halfRoboWidthCm)/(radius-halfRoboWidthCm);
		virtualRightV = speed/tempRatio;
		virtualLeftV = speed;
	}
	//rotate right (clockwise)
	if(dir == dirRight)
	{
		move(virtualRightV,virtualLeftV);
	}//counter clockwise
	else
	{
		move(virtualLeftV,virtualRightV);
	}
}

void resetMotor(int motorNum)
{
	nMotorEncoder[motorNum] = 0;
}

float getMotorDistance(int motorNum)
{
	float curVal = nMotorEncoder[motorNum];
	return (curVal * wheelCerc)/360.0;
}

colour getCurrentColour()
{
	if(SensorValue[LightSensor] > whiteThreshold)
		return white;
	else if(SensorValue[LightSensor] < offThreshold)
		return off;
	return black;
}

void setup()
{

}

void displayInfo()
{
	nxtDisplayCenteredTextLine(lineNum++,"LMot %d",motor[Left]);
	nxtDisplayCenteredTextLine(lineNum++,"RMot %d",motor[Left]);
	displaySensorValues(lineNum++, LightSensor);
	displaySensorValues(lineNum++, DistanceSensor);
	nxtDisplayCenteredTextLine(lineNum++,"LEn %d",nMotorEncoder[Left]);
	nxtDisplayCenteredTextLine(lineNum++,"REn %d",nMotorEncoder[Right]);
	lineNum = 0;
}

void displayInfo(float custom)
{
	displayInfo();
	nxtDisplayCenteredTextLine(lineNum++,"custom %f",custom);
}


bool RightHit = false;
bool DistanceOut = false;

void initialState() {
	rotateRight(45);
	nMotorEncoder[Left] = 0;
	nMotorEncoder[Right] = 0;
	int distanceOut = 360;
	bool running = true;
	while(true){
		moveBackwards();
		if (SensorValue[RightBumpSensor] == 1)  {
			RightHit = true;
			break;
		}
		if (nMotorEncoder[Left] > distanceOut) {
			DistanceOut = true;
			break;
		}
	}
}


void moveBackwards() {
	int speed = 60;
	motor[Left] = speed;
	motor[Right] = speed;

}
void rotateRight(int degrees) {
	int enc = degrees;
	nMotorEncoder[Right]= 0;
	while(abs(nMotorEncoder[Right])<enc) {
		move(-50,50);
		nxtDisplayCenteredTextLine(4,"REn %d",nMotorEncoder[Right]);


	}
	move(0,0);
}

void rotateLeft(int degrees) {
	int enc = degrees;
	nMotorEncoder[Left] = 0;
	while(abs(nMotorEncoder[Left])<enc) {
		move(50,-50);
	}
	move(0,0);
}
