#pragma config(Sensor, S1,     LightSensor,    sensorLightActive)
#pragma config(Sensor, S2,     LeftBumpSensor, sensorTouch)
#pragma config(Sensor, S3,     RightBumpSensor, sensorTouch)
#pragma config(Sensor, S4,     DistanceSensor, sensorSONAR)
#pragma config(Motor,  motorA,          Middle,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          Right,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          Left,          tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "robot.h"


task main()
{
	setup();
	mainloop();
	//wait1Msec(200); //wait 5 seconds
	//float radius = startState();
	//mainloop(ratio);
	//
	//trunState();
	//runState();
}

void mainloop()
{
	initialState();
	bool finished = false;
	while(!finished) {
		turnState();
		attackState();
		//displayInfo();
	}
}

float startState()
{
	bool finished = false;
	float radius = SensorValue[DistanceSensor]/2.0;

	while(!finished)
	{
		displayInfo();
	}
	return radius;
}
void turnState()
{
	while(SensorValue[DistanceSensor] > distanceThreshold)
	{
		checkEdge();
		checkBack();
		rotate(halfRoboWidthCm*2,25,-1);
	}
	move(50,50);
}
void attackState()
{
	move(30,50);//rotate slightly back
	sleep(10);
	
	while(SensorValue[DistanceSensor] < distanceThreshold && SensorValue[DistanceSensor] > 255)  {
		checkEdge();
		checkBack(); 
		move(50,50);
	}
}
void checkBack() {
	if (SensorValue[LeftBumpSensor] == 1) 
	{
		rotate(halfRoboWidthCm*2,25,1);
		sleep(1000);
	}
	else if (SensorValue[RightBumpSensor] == 1){
			rotate(halfRoboWidthCm*2,25,-1);
			sleep(1000);
	}
	else
		return;
}
void checkEdge() {
	displaySensorValues(1, LightSensor);
	if (SensorValue[LightSensor] > whiteThreshold) {
		move(-20,-20);
		sleep(1000); 
	}
	displaySensorValues(1, LightSensor);
}
void runState()
{
}

void move(int leftVal, int rightVal)
{
	setMotor(Left,leftVal*-1);
	setMotor(Right,rightVal*-1);
}

void rotateAndTrack(float radius, int speed, int direction)
{
	
}

void rotate(float radius, int speed, int direction)
{
	
	int virtualRightV;
	int virtualLeftV;
	
	float tempRatio;
	if(radius-halfRoboWidthCm==0)
	{
		tempRatio = 0;
		virtualRightV = speed;
		virtualLeftV = 0;
	}
	else
	{
		tempRatio = (radius+halfRoboWidthCm)/(radius-halfRoboWidthCm);
		virtualRightV = speed/tempRatio;
		virtualLeftV = speed;
	}
	//rotate right (clockwise)
	if(direction > 0)
	{
		move(virtualLeftV,virtualRightV);
	}//counter clockwise
	else
	{
		move(virtualRightV,virtualLeftV);
	}
}

void resetMotor(int motorNum)
{
	nMotorEncoder[motorNum] = 0;
}

float getMotorDistance(int motorNum)
{
	float curVal = nMotorEncoder[motorNum];
	return (curVal * wheelCerc)/360.0;
}

colour getCurrentColour()
{
	if(SensorValue[LightSensor] > whiteThreshold)
		return white;
	else if(SensorValue[LightSensor] < offThreshold)
		return off;
	return black;
}

void setup()
{
	
}

void displayInfo()
{
	//nxtDisplayCenteredTextLine(lineNum++,"LMot %d",motor[Left]);
	//nxtDisplayCenteredTextLine(lineNum++,"RMot %d",motor[Left]);
	displaySensorValues(lineNum++, LightSensor);
	//displaySensorValues(lineNum++, DistanceSensor);
	//nxtDisplayCenteredTextLine(lineNum++,"LEn %d",nMotorEncoder[Left]);
	//nxtDisplayCenteredTextLine(lineNum++,"REn %d",nMotorEncoder[Right]);
	lineNum = 0;
}

void displayInfo(float custom)
{
	displayInfo();
	nxtDisplayCenteredTextLine(lineNum++,"custom %f",custom);
}


bool RightHit = false;
bool DistanceOut = false;

void initialState() {
	rotateRight(20);
	nMotorEncoder[Left] = 0;
	nMotorEncoder[Right] = 0;
	int distanceOut = 360;
	bool running = true;
	while(true){
				moveBackwards();
		if (SensorValue[RightBumpSensor] == 1)  {
			RightHit = true;
			break;
		}
		if (nMotorEncoder[Left] > distanceOut) {
			DistanceOut = true;
			break;
		}
	}
}


void moveBackwards() {
	int speed = 25;
	motor[Left] = speed;
	motor[Right] = speed;

}
void rotateRight(int degrees) {
	int enc = degrees;
	while(abs(nMotorEncoder[Right])<enc) {
		motor[Right] = 50;
			nxtDisplayCenteredTextLine(4,"REn %d",nMotorEncoder[Right]);


	}
	motor[Right] = 0;
}


void rotateLeft(int degrees) {
	int enc = degrees;
	while(abs(nMotorEncoder[Left])<enc) {
		motor[Left] = 50;
	}
	motor[Left] = 0;
}